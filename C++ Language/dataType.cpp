// 주석
// 설명 역할, 코드로 인식되지 않는다.

int main()
{
	// 자료형 (크기 단위, Byte)
	// 정수형 : char(1 Byte), short(2 Byte), int(4 Byte), long(4 Byte), long long(8 Byte)
	// 실수형 : float(4 Byte), double(8 Byte)
	
	// 8 bit == 1 Byte
	// 2^10 Byte == 1024 Byte == 1KB
	// 2^20 Byte == 1024 * 1024 Byte == 1MB
	// 2^30 Byte == 1024 * 1024 * 1024 Byte == 1GB
	// 2^40 Byte == 1024 * 1024 * 1024 * 1024 Byte == 1TB

	// 8 bit의 경우의 수
	// 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 == 2^8 == 256가지

	// 1 Byte로 양수만 표현
	// 1 Byte의 수의 범위 : 256가지 -> 0 ~ 255
	unsigned char c = 0; // 1 Byte == 8 bit

	c = 0; //     [ 0 0 0 0 0 0 0 0 ]
	c = 255; //   [ 1 1 1 1 1 1 1 1 ], 실제 들어가는 값은 255이다
	c = 256; // 1 [ 0 0 0 0 0 0 0 0 ], 실제 들어가는 값은 0이다

	// 1 Byte로 양수와 음수 둘 다 표현
	// 1 Byte의 수의 범위 : 256가지 -> -128 ~ 0 ~ 127
	// 맨 앞의 bit는 부호를 나타낸다, Most Significant Bit
	// MSB -> 0 : 양수, MSB -> 1 : 음수
	char c1 = 0;
	c1 = -1; //  [ 1 1 1 1 1 1 1 1 ]
	c1 = 255; // [ 1 1 1 1 1 1 1 1 ], 실제 들어가는 값은 -1이다

	// 동일한 크기의 메모리 공간에 동일한 값이 들어 있어도 해석에 따라 결과가 달라진다
	// signed와 unsigned의 차이

	// 음의 정수 찾기(2의 보수법)
	// 대응되는 양수의 부호를 반전 후, 1을 더한다
	// [ 0 0 0 0 0 0 1 0 ] == 2
	// [ 1 1 1 1 1 1 0 1 ] + 1 -> [ 1 1 1 1 1 1 1 0 ] == -2
	
	//   [ 0 0 0 0 0 0 1 0 ] == 2
	// + [ 1 1 1 1 1 1 1 0 ] == -2
	// ---------------------
	// 1 [ 0 0 0 0 0 0 0 0 ] == 0

	int a = 4 + 4.0; // 눈에 보이지 않는 형변환 과정이 포함됨, 비효율적이고 손실이 발생할 가능성

	// 실수는 근사값을 표현
	// 정수 표현 방식과 실수 표현 방식은 다르다
	// 따라서 double(8) 자료형이 float(4) 보다 더 많은 소수점 아래 자리까지 정확하게 표현이 가능하다

	// 정수는 정수끼리, 실수는 실수끼리 연산하되 두 표현 방식의 피 연산자가 연산될 경우 명시적으로 변환하자
	float f = 10.2415f + (float)20;

	return 0;
}